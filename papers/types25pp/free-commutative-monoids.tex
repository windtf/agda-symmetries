% !TEX root = types25pp-sort.tex

\section{Constructions of Free Commutative Monoids}
\label{sec:commutative-monoids}

The next step is to add commutativity to the monoid multiplication in each construction of free monoids.
%
Informally, adding commutativity to free monoids turns ``ordered lists'' to ``unordered lists'',
where the ordering is the one imposed by the position or index of the elements in the list.
%
This is crucial to our goal of studying sorting,
as we will study sorting as a function mapping back unordered lists to ordered lists,
later in~\cref{sec:sorting}.

It is known that finite multisets are (free) commutative monoids,
under the operation of multiset union: $\xs \cup \ys = \ys \cup \xs$.
%
The order is ``forgotten'' in the sense that it doesn't matter how two multisets are union-ed together,
such as, $\bag{a, a, b, c} = \bag{b, a, c, a}$ are equal as finite multisets
(justifying the bag notation).
Formally, $\bag{x,y,\dots}$ denotes $\eta_A(x) \mult \eta_A(y) \mult \dots : \MM(A)$.

%
This is unlike free monoids,
where $[a, a, b, c] \neq [b, a, c, a]$ (justifying the list notation).
Formally, $[x, y, \dots]$ denotes $\eta_A(x) \mult \eta_A(y) \mult \dots : \LL(A)$,
and $x \cons xs$ to denote $\eta_A(x) \mult xs : \LL(A)$.

\subsection{Free monoids quotiented by permutation relations}
\label{sec:cmon:qfreemon}

Instead of constructing free commutative monoids directly,
the first construction we study is to take \emph{any} free monoid and quotient by \emph{symmetries}.
%
The constructions in~\cref{sec:cmon:plist} and~\cref{sec:cmon:bag} are specific instances of this recipe.

From the perspective of universal algebra and equational logic developed in~\cref{sec:universal-algebra},
we work in the signature of monoids, but extend the equational theory of monoids with commutativity.
%
If $(\str{F}(A), \eta)$ is a free monoid construction satisfying its universal property,
then we quotient $F(A)$ by an \emph{appropriate} symmetry relation $\approx$.
%
This is precisely a \emph{permutation relation}.

\begin{definition}[\alink{definition}{Permutation relation}{permutation-relation}]
    \label{def:permutation-relation}
    \leavevmode
    A binary relation on a free monoid $(F(A), e, \mult)$ is a permutation relation iff it is:
    \begin{itemize}
        \item reflexive, symmetric, transitive (an equivalence),
        \item a congruence w.r.t $\mult$: $\forall a, b, c, d, \, a \approx b \to c \approx d \to a \mult c \approx b \mult d$,
        \item commutative: $\forall a, b, \, a \mult b \approx b \mult a$, and
        \item respects $\ext{(\blank)}$: $\forall a, b, f, \, a \approx b \to \ext{f}(a) = \ext{f}(b)$.
    \end{itemize}
\end{definition}
%
Note that being a permutation relation is a proposition.
We write $\quot{F(A)}{\approx}$ for the quotient of $F(A)$ by $\approx$,
with the inclusion map $q: F(A) \twoheadrightarrow \quot{F(A)}{\approx}$.
%
The generators map into $\quot{F(A)}{\approx}$ is given by $q \comp \eta_A$,
the identity element is $\qlift{e} = q(e)$,
and the multiplication operation $\mult$ is lifted to $\qlift{\mult}$ in the quotient by congruence.
%
\begin{propositionrep}[\alink{proposition}{}{qfreemon-cmonoid}]
    $(\quot{\str{F}(A)}{\approx}, \qlift{e}, \qlift{\mult})$ is a commutative monoid.
\end{propositionrep}
\begin{proof}
    Since $\approx$ is a congruence w.r.t. $\mult$,
    we can lift $\mult : F(A) \to F(A) \to F(A)$ to the quotient to obtain
    $\qlift{\mult} : \quot{F(A)}{\approx} \to \quot{F(A)}{\approx} \to \quot{F(A)}{\approx}$.
    $\qlift{\mult}$ also satisfies unit and associativity laws on quotiented elements,
    because these laws hold on representatives in $F(A)$.
    Commutativity of $\qlift{\mult}$ follows from the commutativity requirement of $\approx$.
    This makes $(\quot{F(A)}{\approx}, \qlift{e}, \qlift{\mult})$ a commutative monoid.
    Note also that $q(a \mult b) = q(a) \qlift{\mult} q(b)$.
\end{proof}
%
The monoid extension operation of $F(A)$, denoted $\ext{(\blank)}$,
lifts to an extension operation for commutative monoids, for $\quot{F(A)}{\approx}$,
which we denote by $\exthat{(\blank)}$.
%
\begin{definition}[\alink{definition}{}{qfreemon-ext}]
    Given a commutative monoid $\str{X}$ and a map $f : A \to X$,
    we define the extension operation as follows:
    we first obtain $\ext{f} : \str{F}(A) \to \str{X}$ by the universal property of $F$,
    then lift it to $\exthat{f} : \quot{\str{F}(A)}{\approx} \; \to \str{X}$,
    by using that $\approx$ respects $\ext{(\blank)}$, as in~\cref{def:permutation-relation}.
\end{definition}

\begin{propositionrep}[\alink{proposition}{Universal property for $\quot{\str{F}(A)}{\approx}$}{qfreemon-univ}]
    \label{prop:qfreemon}
    \leavevmode
    $(\quot{\str{F}(A)}{\approx}, \eta_A : {A \xto{\eta_A} \str{F}(A) \xto{q} \quot{\str{F}(A)}{\approx}})$
    with the extension operation $\exthat{(\blank)}$ forms the free commutative monoid on $A$.
\end{propositionrep}
\begin{proof}
    We have the following situation.
    % https://q.uiver.app/#q=WzAsNSxbMCwyLCJGKEEpIl0sWzAsNCwiQSJdLFsyLDIsIlgiXSxbMCwwLCJcXHF1b3R7RihBKX17XFxhcHByb3h9Il0sWzIsMCwiWCJdLFsxLDAsIlxcZXRhX3tBfSJdLFswLDIsIlxcZXh0e2Z9Il0sWzEsMiwiZiIsMl0sWzAsMywicSIsMCx7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6ImVwaSJ9fX1dLFsyLDQsIiIsMix7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzMsNCwiXFxleHRoYXR7Zn0iXV0=
    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
            {\quot{F(A)}{\approx}} \&\& X \\
            \\
            {F(A)} \&\& X \\
            \\
            A
            \arrow["{\exthat{f}}", from=1-1, to=1-3]
            \arrow["q", two heads, from=3-1, to=1-1]
            \arrow["{\ext{f}}", from=3-1, to=3-3]
            \arrow[equals, from=3-3, to=1-3]
            \arrow["{\eta_{A}}", from=5-1, to=3-1]
            \arrow["f"', from=5-1, to=3-3]
        \end{tikzcd}\]
    By definition of $\exthat{(\blank)}$, the upper square commutes, and so the whole diagram commutes.

    To see that $\exthat{(\blank)}$ is the right inverse to $(\blank) \comp q \comp \eta_A$,
    observe that $\exthat{f} \comp q \comp \eta_A = \ext{f} \comp \eta_A = f$.
    And,
    $\exthat{f}(q(x) \qlift{\mult} q(y))
        = \exthat{f}{(q(x \mult y))}
        = \ext{f}(x \mult y) = \ext{f}(x) \mult \ext{f}(y)
        = \exthat{f}(q(x)) \mult \exthat{f}(q(y))
    $,
    making $\exthat{f}$ a (commutative) monoid homomorphism.

    To show $\exthat{(\blank)}$ is the left inverse to $(\blank) \comp q \comp \eta_A$,
    we need to show for any commutative monoid homomorphism
    $f : \quot{\str{F}(A)}{\approx} \to \str{X}$, that $\exthat{(f \comp q \comp \eta_A)} = f$.
    It is enough to check on generators, so for any $x : F(A)$,
    we note that $\exthat{(f \comp q \comp \eta_A)}(q(x)) = \ext{(f \comp q \comp \eta_A)}(x) = f(q(x))$
    since $f \comp q$ is a monoid homomorphism, and we are done.

    We have now shown that $(\blank) \comp q \comp \eta_A$ produces an equivalence from
    commutative monoid homomorphisms $\quot{\str{F}(A)}{\approx} \to \str{X}$
    to set functions $A \to X$, and its inverse is given by $\exthat{(\blank)}$, which maps set
    functions $A \to X$ to commutative monoid homomorphisms $\quot{\str{F}(A)}{\approx} \to \str{X}$.
    Therefore, $\quot{\str{F}(A)}{\approx}$ is indeed the free commutative monoid on $A$
    with generators map $q \comp \eta_A$ and extension operation $\exthat{(\blank)}$.
\end{proof}


\subsection{Lists quotiented by permutation relations}
\label{sec:cmon:plist}

A specific instance of this construction is $\List$ quotiented by a concrete permutation relation to get commutativity.
Of course, there are many permutation relations in the literature,
we consider a simple one which swaps any two adjacent elements anywhere in the middle of the list.
This $\PList$ construction has also been considered in~\cite{joramConstructiveFinalSemantics2023},
who prove that $\PList$ is equivalent to the free commutative monoid (constructed as a HIT).
We give a direct proof of its universal property using our generalisation.
%
\begin{definition}[\alink{definition}{Perm}{perm}]
    The inductive family $\Perm$ is generated by two constructors
    and defines a permutation relation on $\List$:
    \begin{align*}
        \term{perm-refl} & : \forall \xs,\, \Perm\,\xs\,\xs \\
        \term{perm-swap} & : \forall x, y, \xs, \ys, \zs,\,
        \Perm\,(\xs \concat x \cons y \cons \ys)\,\zs
        \to \Perm\,(\xs \concat y \cons x \cons \ys)\,\zs
    \end{align*}
    where $\concat$ is the usual list concatenation operation.
    $\PList(A)$ is the quotient of $\List(A)$ by $\Perm$:
    \[
        \PList(A) \defeq \quot{\List(A)}{\Perm}
        \enspace.
    \]
\end{definition}
%
By~\cref{sec:cmon:qfreemon}, it suffices to show $\Perm(A)$ satisfies the axioms of permutation relations
to obtain that $\PList(A)$ is the free commutative monoid on $A$.

\begin{propositionrep}[\alink{proposition}{}{plist-resp-ext}]
    \label{plist:sharp-sat}
    Let $\str{X}$ be a commutative monoid, and $f : A \to X$.
    For $x,y : A$ and $\xs, \ys : \PList(A)$,
    $\ext{f}(\xs\,\concat\,x \cons y \cons \ys) \id \ext{f}(\xs\,\concat\,y \cons x \cons \ys)$.
    Hence, $\Perm$ respects $\ext{(\blank)}$.
\end{propositionrep}
\begin{proof}
    We can prove this by induction on $\xs$. For $\xs = []$, by homomorphism properties of $\ext{f}$,
    we can prove $\ext{f}(x \cons y \cons \ys) = \ext{f}([ x ]) \mult \ext{f}([ y ]) \mult \ext{f}(\ys)$.
    Since the image of $\ext{f}$ is a commutative monoid, we have
    $\ext{f}([ x ]) \mult \ext{f}([ y ]) = \ext{f}([ y ]) \mult \ext{f}([ x ])$, therefore proving
    $\ext{f}(x \cons y \cons \ys) = \ext{f}(y \cons x \cons \ys)$. For $\xs = z \cons \zs$, we can prove
    $\ext{f}((z \cons \zs)\,\concat\,x \cons y \cons \ys) = \ext{f}([ z ]) \mult \ext{f}(\zs\,\concat\,x \cons y \cons \ys)$.
    We can then complete the proof by induction to obtain
    $\ext{f}(\zs\,\concat\,x \cons y \cons \ys) = \ext{f}(\zs\,\concat\,y \cons x \cons \ys)$ and reassembling
    back to $\ext{f}((z \cons \zs)\,\concat\,y \cons x \cons \ys)$ by homomorphism properties of $\ext{f}$.
\end{proof}
%
$\PList$ being a quotient of $\List$ makes it easy to
lift functions and properties defined on $\List$ along the quotient map.
%
The inductive nature of $\Perm$ makes it easy to define algorithms that inductively rearrange elements in a list,
such as insertion sort.
%
This property also makes it possible to normalize inductively constructed list elements in $\PList$
to their simplest forms, e.g. $q([ x ]) \concat q([y, z])$ normalizes to $q([x,y,z])$ by definition,
saving the efforts of defining auxiliary lemmas to prove their equality.

This inductive nature, however, makes it difficult to define efficient operations on $\PList$. Consider a
divide-and-conquer algorithm such as merge sort, which involves partitioning a $\PList$ of length $n+m$ into
two smaller $\PList$ of length $n$ and length $m$.
%
We must iterate all $n$ elements before we can make such a partition, thus making $\PList$ unintuitive
to work with when we want to reason with operations that involve arbitrary partitioning.
\begin{toappendix}
    Whenever we define a function on $\PList$ by pattern matching we would also need to show
    the function respects $\Perm$, i.e. $\Perm \as\,\bs \to f(\as) = f(\bs)$. This can be annoying because
    of the many auxiliary variables in the constructor $\term{perm-swap}$, namely $\xs$, $\ys$, $\zs$.
    We need to show $f$ would respect a swap in the list anywhere between $\xs$ and $\ys$, which can
    unnecessarily complicate the proof. For example in the inductive step of~\cref{plist:sharp-sat},
    $\ext{f}((z \cons \zs)\,\concat\,x \cons y \cons \ys) = \ext{f}([ z ]) \mult \ext{f}(\zs\,\concat\,x \cons y \cons \ys)$,
    to actually prove this in Cubical Agda would involve first applying associativity to prove
    $(z \cons \zs)\,\concat\,x \cons y \cons \ys = z \cons (\zs\,\concat\,x \cons y \cons \ys)$, before we can actually
    apply homomorphism properties of $f$. In the final reassembling step, similarly,
    we also need to re-apply associativity to go from $z \cons (\zs\,\concat\,y \cons x \cons \ys)$
    to $(z \cons \zs)\,\concat\,y \cons x \cons \ys$. Also since we are working with an equivalence relation we
    defined ($\Perm$) and not the equality type directly, we cannot exploit the many combinators defined
    in the standard library for the equality type and often needing to re-define combinators ourselves.
\end{toappendix}

\subsection{Swap Lists}
\label{sec:cmon:slist}

Informally, quotients are defined by generating all the points, then quotienting out into equivalence classes by the
congruence relation.
%
Alternately, HITs use generators (points) and higher generators (paths) (and higher higher generators and so on\ldots).
%
We can also define free commutative monoids using HITs where adjacent swaps generate all symmetries,
for example swap-lists taken from \cite{choudhuryFreeCommutativeMonoids2023},
and in the Cubical library~\cite{theagdacommunityCubicalAgdaLibrary2025}.
%
\begin{definition}[\alink{definition}{$\SList$}{slist}]
    \label{def:slist}
    The higher inductive type $\SList(A)$ is generated by:
    \begin{align*}
        \nil              & : \SList(A)                                                   \\
        \blank\cons\blank & : A \to \SList(A) \to \SList(A)                               \\
        \term{swap}       & : \forall x, y, xs,\, x \cons y \cons xs = y \cons x \cons xs \\
        \term{trunc}      & : \forall x, y,\, (p, q : x = y) \to p = q
    \end{align*}
\end{definition}
%
\begin{toappendix}
    \begin{definition}[Concatenation]
        We define the concatenation operation $\concat : \SList(A) \to \SList(A) \to \SList(A)$
        recursively, where we also have to consider the (functorial) action on the $\term{swap}$ path using $\term{ap}$.
        \begin{align*}
            [] \concat \ys                                  & \defeq \ys                           \\
            (x \cons \xs) \concat \ys                       & \defeq x \cons (\xs \concat \ys)     \\
            \term{ap}_{\concat \ys}(\term{swap}(x, y, \xs)) & = \term{swap}(x, y, \ys \concat \xs)
        \end{align*}
    \end{definition}
    %
    A proof of $(\SList(A), \concat, [])$ satisfying commutative monoid laws
    is given in~\cite{choudhuryFreeCommutativeMonoids2023} and the Cubical Agda library~\cite{theagdacommunityCubicalAgdaLibrary2025}.
    %
    We explain the proof of $\concat$ satisfying commutativity here.

    \begin{lemma}[Head rearrange]\label{slist:cons}
        For all $x : A$, $\xs : \SList(A)$, $x \cons \xs = \xs \concat [ x ]$.
    \end{lemma}

    \begin{proof}
        We can prove this by induction on $\xs$.
        For $\xs \jdgeq []$ this is trivial. For $\xs \jdgeq y \cons \ys$, we have the induction hypothesis $x \cons \ys = \ys \concat [ x ]$.
        By applying $y \cons (\blank)$ on both sides and then applying a $\term{swap}$, we complete the proof.
    \end{proof}

    \begin{theorem}[Commutativity]\label{slist:comm}
        For all $\xs,\,\ys : \SList(A)$, $\xs \concat \ys = \ys \concat \xs$.
    \end{theorem}

    \begin{proof}
        By induction on $\xs$ we can iteratively apply~\cref{slist:cons} to move all elements of $\xs$
        to after $\ys$. This moves $\ys$ to the head and $\xs$ to the end, thereby proving
        $\xs \concat \ys = \ys \concat \xs$.
    \end{proof}
\end{toappendix}
%
We refer the reader to~\cite{choudhuryFreeCommutativeMonoids2023} or the Cubical Agda library~\cite{theagdacommunityCubicalAgdaLibrary2025}
for further details.
%
Much like $\List$, $\SList$ is inductively defined, therefore making it intuitive to reason
with when defining inductive operations or proofs on $\SList$, but difficult to reason with
when defining operations that involve arbitrary partitioning, for reasons similar to those given
in~\cref{sec:cmon:plist}.

\begin{toappendix}
    Unlike $\PList$ which is defined as a set quotient, $\SList$ is defined as a HIT, therefore handling equalities
    between $\SList$ is much simpler than $\PList$. We would still need to prove a function $f$ respects
    the path constructor of $\SList$ when pattern matching, i.e. $f(x \cons y \cons \xs) = f(y \cons x \cons \xs)$.
    Unlike $\PList$ we do not need to worry about as many auxiliary variables since swap
    only happens at the head of the list, whereas with $\PList$ we would need to prove
    $f(\xs\,\concat\,x \cons y \cons \ys) = f(\xs\,\concat\,y \cons x \cons \ys)$. One may be tempted to just remove $\xs$
    from the $\term{perm-swap}$ constructor such that it becomes
    $\term{perm-swap} : \Perm\,(x \cons y \cons \ys)\,\zs \to \Perm\,(y \cons x \cons \ys)\,\zs$.
    However this would break $\Perm$'s congruence w.r.t. $\concat$, therefore violating the axioms of
    permutation relations. Also, since we are working with the identity type directly, properties we would
    expect from $\term{swap}$, such as reflexivity, transitivity, symmetry, congruence and such all comes directly by
    construction, whereas with $\Perm$ we would have to prove these properties manually.
    We can also use the many combinatorics defined in the standard library for equational reasoning,
    making the handling of $\SList$ equalities a lot simpler.
\end{toappendix}

\subsection{Bag}
\label{sec:cmon:bag}

Alternatively, we can also quotient $\Array$ by symmetries to get commutativity.
%
This construction is first considered in~\cite{altenkirchDefinableQuotientsType2011}
and~\cite{liQuotientTypesType2015},
partially considered in~\cite{choudhuryFreeCommutativeMonoids2023},
and in in~\cite{joramConstructiveFinalSemantics2023},
who gave a similar construction, where only the index function is quotiented, instead of
the entire array.
%
\cite{danielssonBagEquivalenceProofRelevant2012} also considered $\Bag$ as a setoid relation
on $\List$ in an intensional MLTT setting.
%
\cite{joramConstructiveFinalSemantics2023} prove that their version of $\Bag$
is the free commutative monoid by equivalence to the other HIT constructions.
%
We give a direct proof of its universal property instead, using our general recipe.

\begin{definition}[\alink{definition}{Bag}{bag}]
    \label{def:bag}
    Bags are defined as arrays quotiented by bag equivalence $\approx$:
    %
    \begin{align*}
        (n , f) \approx (m , g) & \defeq \dsum{\sigma : \Fin[n] \xto{\sim} \Fin[m]} (f = g \comp \sigma)
        \\
        \Bag(A)                 & \defeq \quot{\Array(A)}{\approx}
    \end{align*}
\end{definition}
%
Note that by a pigeonhole argument,
$\sigma$ may only be constructed when $n = m$.
%
In other words, we are quotienting by an automorphism on the indices,
and its action on the elements.
%
We have already shown $\Array$ to be the free monoid in~\cref{sec:arrays}.
%
By~\cref{prop:qfreemon}, it suffices to show that $\approx$ satisfies
the axioms of permutation relations to establish that $\Bag$
is the free commutative monoid.
%
\begin{toappendix}
    \begin{proposition}[\alink{proposition}{}{bag-equiv}]
        $\approx$ is a equivalence relation.
    \end{proposition}
    \begin{proof}
        We can show any array $\xs$ is related to itself by the identity isomorphism, therefore $\approx$ is reflexive.
        If $\xs \approx \ys$ by $\sigma$, we can show $\ys \approx \xs$ by $\sigma^{-1}$, therefore $\approx$ is symmetric.
        If $\xs \approx \ys$ by $\sigma$ and $\ys \approx \zs$ by $\phi$, we can show $\xs \approx \zs$ by $\sigma \comp \phi$,
        therefore $\approx$ is transitive.
    \end{proof}
\end{toappendix}
%
\begin{proposition}[\alink{proposition}{}{bag-cong}]
    \label{bag:cong}
    $\approx$ is congruent w.r.t. $\concat$.
\end{proposition}
%
\begin{proof}
    Given $(n, f) \approx (m, g)$ by $\sigma$ and $(u, p) \approx (v, q)$ by $\phi$,
    we want to show $(n, f) \concat (u, p) \approx (m, g) \concat (v, q)$ by some $\tau$.
    We construct $\tau$ as follows:
    \[
        \tau \defeq \Fin[n+u] \xto{\sim} \Fin[n] + \Fin[u] \xto{\sigma,\,\phi} \Fin[m] + \Fin[v] \xto{\sim} \Fin[m+v] \\
    \]
    which operationally performs:
    \[
        % https://q.uiver.app/#q=WzAsMixbMCwwLCJcXHswLDEsXFxkb3RzLG4tMSwgbixuKzEsXFxkb3RzLG4rbS0xXFx9Il0sWzAsMSwiIFxce24sbisxXFxkb3RzLG4rbS0xLDAsMSxcXGRvdHMsbi0xXFx9Il0sWzAsMSwiIiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoibWFwcyB0byJ9fX1dXQ==
        \begin{tikzcd}[ampersand replacement=\&,cramped]
            {\{\color{red}0,1,\dots,n-1, \color{blue} n,n+1,\dots,n+u-1 \color{black}\}} \\
            { \{\color{red}\sigma(0),\sigma(1)\dots,\sigma(n-1), \color{blue}\phi(0),\phi(1),\dots,\phi(u-1) \color{black}\}}
            \arrow["{\sigma,\phi}", maps to, from=1-1, to=2-1]
        \end{tikzcd}
        \enspace.
    \]
\end{proof}
%
\begin{proposition}[\alink{proposition}{}{bag-comm}]
    \label{bag:comm}
    $\approx$ respects commutativity.
\end{proposition}

\begin{proof}
    We want to show for any arrays $(n, f)$ and $(m, g)$, $(n, f) \mult (m, g) \approx (m, g) \mult (n, f)$
    by some $\phi$.
    We use formal combinators (see~\cite{choudhurySymmetriesReversibleProgramming2022}) to define $\phi$:
    \[
        \phi \defeq \Fin[n+m] \xto{\sim} \Fin[n] + \Fin[m] \xto{\term{swap}_{+}} \Fin[m] + \Fin[n] \xto{\sim} \Fin[m+n] \\
    \]
    which operationally performs:
    \[
        % https://q.uiver.app/#q=WzAsMixbMCwwLCJcXHswLDEsXFxkb3RzLG4tMSwgbixuKzEsXFxkb3RzLG4rbS0xXFx9Il0sWzAsMSwiIFxce24sbisxXFxkb3RzLG4rbS0xLDAsMSxcXGRvdHMsbi0xXFx9Il0sWzAsMSwiIiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoibWFwcyB0byJ9fX1dXQ==
        \begin{tikzcd}[ampersand replacement=\&,cramped]
            {\{\color{red}0,1,\dots,n-1, \color{blue} n,n+1,\dots,n+m-1 \color{black}\}} \\
            { \{\color{blue}n,n+1\dots,n+m-1, \color{red}0,1,\dots,n-1 \color{black}\}}
            \arrow["\phi", maps to, from=1-1, to=2-1]
        \end{tikzcd}
        \enspace.
    \]
\end{proof}
%
To show that $\ext{f}$ is invariant under permutation: for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]$,
$\ext{f}(n, i) \id \ext{f}(n, i \circ \phi)$, we need some formal combinators for
\emph{punching in} and \emph{punching out} indices. These operations are
borrowed from~\cite{mozlerCubicalAgdaSimple2021} and
developed further
in~\cite{choudhurySymmetriesReversibleProgramming2022} for studying permutation codes.
%
\begin{lemma}[\alink{lemma}{}{bag-tau}]
    \label{bag:tau}
    Given $\phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$, there is a permutation $\tau\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$
    such that $\tau(0) = 0$, and $\ext{f}(S(n), i \circ \phi) = \ext{f}(S(n), i \circ \tau)$.
\end{lemma}

\begin{proof}
    Let $k$ be $\phi^{-1}(0)$, and $k + j = S(n)$, we construct $\tau$:
    \[
        \tau \defeq \Fin[S(n)] \xto{\phi} \Fin[S(n)] \xto{\sim} \Fin[k+j] \xto{\sim} \Fin[k] + \Fin[j]
        \xto{\term{swap}_{+}} \Fin[j] + \Fin[k] \xto{\sim} \Fin[j+k] \xto{\sim} \Fin[S(n)]
    \]
    \[
        \begin{tikzcd}[ampersand replacement=\&,cramped]
            {\{\color{blue}0, 1, 2, \dots, \color{red}k, k+1, k+2, \dots \color{black}\}} \\
            {\{\color{blue}x, y, z, \dots, \color{red}0, u, v, \dots \color{black}\}}
            \arrow["\phi", maps to, from=1-1, to=2-1]
        \end{tikzcd}
        \\
        \begin{tikzcd}[ampersand replacement=\&,cramped]
            {\{\color{blue}0, 1, 2, \dots, \color{red}k, k+1, k+2, \dots \color{black}\}} \\
            {\{\color{red}0, u, v, \dots, \color{blue}x, y, z, \dots \color{black}\}}
            \arrow["\tau", maps to, from=1-1, to=2-1]
        \end{tikzcd}
    \]
    It is trivial to show $\ext{f}(S(n), i \circ \phi) = \ext{f}(S(n), i \circ \tau)$, since the only
    operation on indices in $\tau$ is $\term{swap}_{+}$. It suffices to show $(S(n), i \circ \phi)$
    can be decomposed into two arrays such that $(S(n), i \circ \phi) = (k, g) \concat (j, h)$
    for some $g$ and $h$. Since the image of $\ext{f}$ is a commutative monoid, and $\ext{f}$ is a homomorphism,
    $\ext{f}((k, g) \concat (j, h)) = \ext{f}(k, g) \mult \ext{f}(j, h) = \ext{f}(j, h) \mult \ext{f}(k, g) =
        \ext{f}((j, h) \concat (k, g))$, thereby proving $\ext{f}(S(n), i \circ \phi) = \ext{f}(S(n), i \circ \tau)$.

\end{proof}

\begin{lemma}[\alink{lemma}{}{bag-punch}]
    \label{bag:punch}
    Given $\tau\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$ where $\tau(0) = 0$,
    there is a $\psi : \Fin[n] \xto{\sim} \Fin[n]$ such that $\tau \circ S = S \circ \psi$.
\end{lemma}

\begin{proof}
    We construct $\psi$ as $\psi(x) = \tau(S(x)) - 1$.
    %
    Since $\tau$ maps only 0 to 0 by assumption, $\forall x. \, \tau(S(x)) > 0$, therefore
    the $(- 1)$ is well defined. This is the special case for $k = 0$ in the punch-in and punch-out
    equivalence for Lehmer codes in~\cite{choudhurySymmetriesReversibleProgramming2022}.
    \[
        \begin{tikzcd}[ampersand replacement=\&,cramped]
            {\{\color{blue}0, \color{red}1, 2, 3, \dots \color{black}\}} \\
            { \{\color{blue}0, \color{red} x, y, z \dots \color{black}\}}
            \arrow["\tau", maps to, from=1-1, to=2-1]
        \end{tikzcd}
        \\
        \begin{tikzcd}[ampersand replacement=\&,cramped]
            {\{\color{red}0, 1, 2, \dots \color{black}\}} \\
            { \{\color{red} x-1, y-1, z-1 \dots \color{black}\}}
            \arrow["\psi", maps to, from=1-1, to=2-1]
        \end{tikzcd}
    \]
\end{proof}

\begin{theorem}[\alink{theorem}{Permutation invariance}{bag-perm-sat}]
    \label{bag:perm-sat}
    For all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]$, $\ext{f}(n, i) \id \ext{f}(n, i \circ \phi)$.
\end{theorem}

\begin{proof}
    By induction on $n$.
    \begin{itemize}
        \item At $n = 0$, $\ext{f}(0, i) \id \ext{f}(0, i \circ \phi) = e$.
        \item At $n = S(m)$,
              \begin{align*}
                   & \mathrel{\phantom{=}} \ext{f}(S(m), i \circ \phi)                                                 \\
                   & = \ext{f}(S(m), i \circ \tau)                          & \text{by~\cref{bag:tau}}                 \\
                   & = f(i(\tau(0))) \mult \ext{f}(m, i \circ \tau \circ S) & \text{by definition of $\ext{(\blank)}$} \\
                   & = f(i(0)) \mult \ext{f}(m, i \circ \tau \circ S)       & \text{by construction of $\tau$}         \\
                   & = f(i(0)) \mult \ext{f}(m, i \circ S \circ \psi)       & \text{by~\cref{bag:punch}}               \\
                   & = f(i(0)) \mult \ext{f}(m, i \circ S)                  & \text{induction}                         \\
                   & = \ext{f}(S(m), i)                                     & \text{by definition of $\ext{(\blank)}$}
              \end{align*}
    \end{itemize}
\end{proof}
%
Unlike $\PList$ and $\SList$, $\Bag$ and its underlying construction $\Array$ are not inductively defined,
making it difficult to do induction on them. For example,
in the proof of~\cref{array:univ}, both~\cref{array:eta-suc,array:split} are needed to do
induction on $\Array$, as opposed to $\List$ and its quotients, where we can do induction simply by
pattern matching. Much like $\PList$, when defining functions on $\Bag$, we need to show they respect
$\approx$, i.e. $\as \approx \bs \to f(\as) = f(\bs)$. Notably, this is much more difficult than
$\PList$ or $\SList$ -- with $\PList$ and $\SList$ we only need to consider swapping adjacent elements,
while with $\Bag$ we need to consider all possible permutations. For example,
in the proof of~\cref{bag:perm-sat}, we need to first construct a $\tau$ which satisfies $\tau(0) = 0$ and prove
$\ext{f}(n, i \comp \sigma) = \ext{f}(n, i \comp \tau)$ before we can apply induction.

\begin{toappendix}
    Since $\Array$ and $\Bag$ are not simple data types, the definition of
    the monoid operation on them $\concat$ are necessarily more complicated, and unlike $\List$, $\PList$
    and $\SList$, constructions of $\Array$ and $\Bag$ via $\concat$ often would not normalize into a
    very simple form, but would instead expand into giant trees of terms. This makes it such that when working
    with $\Array$ and $\Bag$ we need to be very careful or otherwise Agda would be stuck trying to display
    the normalized form of $\Array$ and $\Bag$ in the goal and context menu. Type-checking also becomes a lengthy
    process that tests if the user possesses the virtue of patience.

    However, performing arbitrary partitioning with $\Array$ and $\Bag$ is much easier than
    $\List$, $\SList$, $\PList$. For example,
    one can simply use the combinator ${\Fin[n+m] \xto{\sim} \Fin[n] + \Fin[m]}$ to partition the array,
    then perform operations on the partitions, such as swapping in~\cref{bag:comm},
    or perform operations on the partitions individually, such as two individual permutations in~\cref{bag:cong}.
    This makes it so that when defining divide-and-conquer algorithms like merge sort,
    $\Bag$ and $\Array$ are more natural representations to work with than $\List$, $\SList$, or $\PList$.
\end{toappendix}
