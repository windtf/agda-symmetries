% !TEX root = types25pp-sort.tex

\subsection{Prelude}
\label{sec:prelude}

Any presentation of free monoids or free commutative monoids has a $\term{length} : \FF(A) \to \Nat$ function,
where $\Nat$ carries the additive monoid structure $(0,+)$,
which is also a commutative monoid structure since addition is commutative.
%
\begin{definition}[\alink{definition}{length}{length}]
      \label{def:length}
      The length homomorphism is defined as
      \(
      \ext{(\lambda x.\, 1)} : \FF(A) \to \Nat
      \).
\end{definition}
%
Further, any presentation of free monoids or free commutative monoids has an
element membership predicate ${\blank\in\blank} : A \to \FF(A) \to \hProp$,
for any set $A$.
%
Here, we use the fact that $\hProp$ forms a (commutative) monoid under
disjunction and falsehood $(\bot, \vee)$.
%
\begin{definition}[\alink{definition}{Membership~$\in$}{membership}]
      \label{def:membership}
      The membership predicate on a set $A$ for any element $x:A$ is
      \(
      {x\in\blank} \defeq \ext{\yo_{A}(x)} : {\FF(A) \to \hProp}
      \),
      where we define
      \(
      \yo_A(x) \defeq {\lambda y.\, {x \id y}} : {A \to \hProp}
      \).
\end{definition}
%
$\yo$ is formally the Yoneda map under the ``types are groupoids'' correspondence,
where $x:A$ is being sent to its representable in the Hom-groupoid (formed by the identity type), of type $\hProp$.
%
Note that the proofs of (commutative) monoid laws for $\hProp$ use equality,
which requires the use of univalence (or at least, propositional extensionality).
%
By construction, this membership predicate satisfies its homomorphic properties,
which are colloquially the properties of inductively defined de Bruijn indices.

We note that $\hProp$ is actually one type level higher than $A$.
To make the type level explicit, $A$ is of type level $\ell$, and since $\hProp_\ell$
is the type of all types $X : \Set_\ell$ that are mere propositions, $\hProp_\ell$ has
type level $\ell + 1$. We do not assume any propositional resizing axioms~\cite{voevodskyResizingRulesTheir2011},
and use level polymorphism $\ext{(\blank)}$ in our formalisation to accommodate this.

Any presentation of free (commutative) monoids $\FF(A)$ also supports the
$\term{Any}$ and $\term{All}$ predicates, which allow lifting a predicate $A \to \hProp$ (on $A$),
to \emph{any} or \emph{all} elements of $\xs : \FF(A)$, respectively.
%
We note that $\hProp$ forms a (commutative) monoid in two different ways:
$(\bot,\vee)$ and $(\top,\wedge)$ (disjunction and conjunction),
which are the two different ways of getting $\term{Any}$ and $\term{All}$,
respectively, by extension.
\begin{definition}[$\term{Any}$ and $\term{All}$]
      \label{def:any-all}
      \begin{gather*}
            \type{Any}(P) \defeq \ext{P} : \FF(A) \to (\hProp, \bot, \vee)
            \qquad
            \type{All}(P) \defeq \ext{P} : \FF(A) \to (\hProp, \top, \wedge)
      \end{gather*}
\end{definition}
%
Note that Cubical Agda has problems with indexing over HITs~\cite[\S~8]{ProperSupportInductive,alexandruIntrinsicallyCorrectSorting2023}
hence it is preferable to program with our universal properties, such as when defining $\term{Any}$ and $\term{All}$,
because the indexed-inductive definitions of these predicates get stuck on $\term{transp}$ terms.

There is a $\term{head}$ function on lists, which is a function that returns the first element of a non-empty list.
%
Formally, this is a monoid homomorphism from $\LL(A)$ to $1 + A$.
%
\begin{definition}[\alink{definition}{$\term{head}$}{head}]
      \label{def:head-free-monoid}
      The head homomorphism is defined as
      \(
      \term{head} \defeq \ext{\inr} : \LL(A) \to 1 + A
      \),
      where the monoid structure on $1 + A$ has unit
      \(
      e \defeq \inl(\ttt) : 1 + A
      \),
      and multiplication picks the leftmost element that is defined.
      \[
            \begin{array}{rclcl}
                  \inl(\ttt) & \oplus & b & \defeq & b       \\
                  \inr(a)    & \oplus & b & \defeq & \inr(a) \\
            \end{array}
      \]
\end{definition}
%
This monoid operation $\oplus$ is not commutative,
since swapping the input arguments to $\oplus$ would return the leftmost or rightmost element.
%
To make it commutative would require a canonical way to pick between a choice of two elements --
this leads us to the next section.
