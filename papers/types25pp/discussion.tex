% !TEX root = types25pp-sort.tex

\section{Discussion}
\label{sec:discussion}

We conclude by discussing some high-level observations, related work, and future directions.

\myparagraph{Formalisation}
%
The paper uses informal type theoretic language,
and is accessible without understanding any details of the formalisation.
However, the formalisation is done in Cubical Agda, which has a few differences and
shortcomings, that cause certain details to be more verbose than they are in informal type theory.

For simplicity we omitted type levels in the paper,
but our formalisation has many verbose uses of universe levels due to Agda's universe polymorphism.
Similarly, h-levels were restricted to sets in the paper, but the formalisation is parameterised in many places for any
h-level (to facilitate future generalisations).
The free algebra framework currently only works with sets.
Due to issues of regularity, certain computations only hold propositionally,
and the formalisation requires proving auxiliary $\beta$ and $\eta$ computation rules in some places.

\myparagraph{Universal Algebra}
%
One of the contributions of our work is a rudimentary framework for universal algebra, but done in a more
categorical style, which lends itself to an elegant formalisation in type theory.
%
This framework may be improved and generalised from sets to groupoids --
using a system of coherences on top of a system of equations,
to talk about 2-algebraic structures on groupoids,
such as monoidal groupoids, symmetric monoidal groupoids, and so on.
%

\myparagraph{Free commutative monoids}
%
The construction of finite multisets and free commutative monoids in type theory has a long history,
and various authors have different approaches to it. We refer the reader to the discussions
in~\cite{choudhuryFreeCommutativeMonoids2023,joramConstructiveFinalSemantics2023} for a detailed survey of these
constructions.
%
Our work, in particular, was motivated by the colloquial observation that:
``there is no way to represent free commutative monoids using inductive types''.
%
From the categorical point of view, note that the free monoid functor on $\Set$ is polynomial,
but the free commutative monoid endofunctor is not polynomial, since it only weakly preserves pullbacks.
%
Various authors have given clever encodings of free commutative monoids using inductive types by adding
assumptions on the carrier set -- in particular, the assumption of total ordering on the carrier set leads to the
construction of ``fresh-lists'', by~\cite{kupkeFreshLookCommutativity2023}, which forces the canonical \emph{sorted}
ordering on the elements of the finite multiset.

It is worth noting that in programming practice,
it is usually the case that all user-defined types have some sort of total order enforced on them,
either because they're finite, or because they can be canonically enumerated.
%
Under these assumptions, the construction of fresh lists is a very reasonable way to represent free
commutative monoids, or finite multisets.

The free monoid and free commutative monoid constructions can be categorified
to free monoidal categories and free symmetric monoidal categories, respectively.
%
In type theory, these types can be groupoidified to free monoidal groupoids and free symmetric monoidal groupoids,
using the groupoid structure of identity types.
%
This is a natural next step,
and its connections to assumptions about total orders on the type of objects would be an important direction to explore.

\myparagraph{Correctness of Sorting}
%
Sorting is a classic problem in computer science --
the programming point of view of sorting and its correctness has been studied by various authors.
%
The simplest view of sorting is a function $\term{sort}: \LL(\Nat) \to \LL(\Nat)$,
which permutes the list and outputs an ordered list, which is studied in~\cite{appelVerifiedFunctionalAlgorithms2023}.
%
Fundamentally, this is a very extrinsic view of program verification,
which is commonly used in program verification and proof assistants,
and further, a special case of a more general sorting algorithm.

%% TODO: fix citation commands
%% \citeauthor*{hengleinWhatSortingFunction2009} in~\citetitle{hengleinWhatSortingFunction2009}
Henglein~\cite{hengleinWhatSortingFunction2009} studies sorting functions abstractly,
without requiring a total order on the underlying set.
%
He considers sorting functions as functions on sequences (lists),
and recovers the order by applying a ``sorting function'' on an $n$-element list,
and looking up the position of the elements to be compared.
%
Unlike our approach, he does not factorize sorting functions through free commutative monoids.
%
Henglein also studies sorting on preorders where antisymmetry may not hold,
whereas we have only considered total orders in this paper.
%
We are able to give a more refined axiomatisation of sorting because we consider permutations
explicitly, and work in a constructive setting (using explicit assumptions about decidability),
and which is an improvement over previous work.

Another intrinsic view of correctness of sorting has been studied in~\cite{hinzeSortingBialgebrasDistributive2012}
using bialgebras, which was further expanded in~\cite{alexandruIntrinsicallyCorrectSorting2023} with an accompanying formalisation in Cubical Agda,
that matches our point of view, as explained in~\cref{prop:sort-correctness}.
%
However, their work is not just about extensional correctness of sorting,
but also deriving various sorting algorithms starting from bialgebraic semantics and distributive laws.
%
Our work is complementary, in that we are not concerned with the computational content of sorting, but rather
the abstract properties of sorting functions, which are independent of a given ordering.
%
It is unclear whether the abstract property of sorting functions can be combined
with the intrinsic complexity of sorting algorithms --
and that is a direction for future work.

Although we only talk about sorting lists and bags,
the same ideas can be applied to other inductive types (polynomial functors) such as trees.
%
We speculate that this could lead to some interesting connections with sorting
(binary) trees, and constructions of (binary) search trees, from classical computer science.
