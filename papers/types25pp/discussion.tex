% !TEX root = types25pp-sort.tex

\section{Discussion}
\label{sec:discussion}

We conclude by discussing some high-level observations, related work, and future directions.

\myparagraph{Formalisation}
%
The paper uses informal type theoretic language,
and is accessible without understanding any details of the formalisation.
However, the formalisation is done in Cubical Agda, which has a few differences and
shortcomings, that cause certain details to be more verbose than they are in informal type theory.

For simplicity we omitted type levels in the paper,
but our formalisation has many verbose uses of universe levels due to Agda's universe polymorphism.
Similarly, h-levels were restricted to sets in the paper, but the formalisation is parameterized in many places for any
h-level (to facilitate future generalisations).
The free algebra framework currently only works with sets.
Due to issues of regularity, certain computations only hold propositionally,
and the formalisation requires proving auxiliary $\beta$ and $\eta$ computation rules in some places.
We also note that the axioms of sorting in the formalisation are named differently from the paper.

\myparagraph{Free commutative monoids}
%
The construction of finite multisets and free commutative monoids has a long history, and various authors have different
approaches to it. We refer the reader to the discussions
in~\cite{choudhuryFreeCommutativeMonoids2023,joramConstructiveFinalSemantics2023} for a detailed survey of these
constructions.
%
Our work, in particular, was motivated by the colloquial observation that:
``there is no way to represent free commutative monoids using inductive types''.
%
From the categorical point of view, this is simply the fact that the free commutative monoid endofunctor on $\Set$ is
not polynomial.
%
Various authors have given clever encodings of free commutative monoids using inductive types by adding
assumptions on the carrier set -- in particular, the assumption of total ordering on the carrier set leads to the
construction of ``fresh-lists'', by~\cite{kupkeFreshLookCommutativity2023}, which forces the canonical \emph{sorted}
ordering on the elements of the finite multiset.

It is worth noting that in programming practice,
it is usually the case that all user-defined types have some sort of total order enforced on them,
either because they're finite, or they can be canonically enumerated.
%
Under these assumptions, the construction of fresh lists is a very reasonable way to represent free
commutative monoids, or finite multisets.

\myparagraph{Correctness of Sorting}
%
Sorting is a classic problem in computer science --
the programming point of view of sorting and its correctness has been studied by various authors.
%
The simplest view of sorting is a function $\term{sort}: \LL(\Nat) \to \LL(\Nat)$,
which permutes the list and outputs an ordered list, which is studied in~\cite{appelVerifiedFunctionalAlgorithms2023}.
%
Fundamentally, this is a very extrinsic view of program verification, which is common in the \emph{Coq} community,
and further, a very special case of a more general sorting algorithm.

%% TODO: fix citation commands
%% \citeauthor*{hengleinWhatSortingFunction2009} in~\citetitle{hengleinWhatSortingFunction2009}
Henglein~\cite{hengleinWhatSortingFunction2009} studies sorting functions abstractly,
without requiring a total order on the underlying set.
%
He considers sorting functions as functions on sequences (lists),
and recovers the order by applying a ``sorting function'' on an $n$-element list,
and looking up the position of the elements to be compared.
%
Unlike our approach, he does not factorize sorting functions through free commutative monoids.
%
Henglein also studies sorting on preorders where antisymmetry may not hold,
whereas we have only considered total orders in this paper.
%
We are able to give a more refined axiomatisation of sorting because we consider permutations
explicitly, and work in a constructive setting (using explicit assumptions about decidability),
and which is an improvement over previous work.

Another intrinsic view of correctness of sorting has been studied in~\cite{hinzeSortingBialgebrasDistributive2012}
using bialgebras, which was further expanded in~\cite{alexandruIntrinsicallyCorrectSorting2023} with an accompanying formalisation in Cubical Agda,
that matches our point of view, as explained in~\cref{prop:sort-correctness}.
%
However, their work is not just about extensional correctness of sorting,
but also deriving various sorting algorithms starting from bialgebraic semantics and distributive laws.
%
Our work is complementary, in that we are not concerned with the computational content of sorting, but rather
the abstract properties of sorting functions, which are independent of a given ordering.
%
It is unclear whether the abstract property of sorting functions can be combined
with the intrinsic complexity of sorting algorithms --
and that is a direction for future work.
%
Although we only talk about sorting lists and bags,
the same ideas can be applied to other inductive types such as trees.
%
We speculate that this could lead to some interesting connections with sorting
(binary) trees, and constructions of (binary) search trees, from classical computer science.

\subsubsection*{Universal Algebra}

One of the contributions of our work is also a rudimentary framework for universal algebra, but done in a more
categorical style, which lends itself to an elegant formalisation in type theory.
%
We believe this framework could be improved and generalised from sets to groupoids,
and using a system of coherences on top of a system of equations,
to talk about 2-algebraic structures on groupoids, such as monoidal groupoids and symmetric monoidal groupoids.
%
Groupoidyfying free (commutative) monoids to free (symmetric) monoidal groupoids is a natural next step, and its
connections to assumptions about total orders on the type of objects would be an important direction to explore.
